---
// No props
---
<style is:global>
  #bg-canvas { position: fixed; inset: 0; z-index: 0; display:block; width:100%; height:100%; }
  @media (prefers-reduced-motion: reduce){ #bg-canvas { display:none; } }
</style>
<canvas id="bg-canvas" aria-hidden="true"></canvas>
<script>
  // @ts-nocheck
  // Reimagined background: aurora blobs + parallax stars + constellation lines + gentle waves
  // Smooth, performant, and responsive to VOCALOID mode tint via localStorage('vocaloidMode')
  const reduce = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  if (!reduce) {
    const el = document.getElementById('bg-canvas');
    /** @type {HTMLCanvasElement | null} */
    const cvs = el instanceof HTMLCanvasElement ? el : null;
    if (!cvs) { /* no canvas present */ }
    /** @type {CanvasRenderingContext2D | null} */
    const ctx = cvs?.getContext('2d');
    const DPR = Math.min(window.devicePixelRatio || 1, 2);

    let W = 0, H = 0, T = 0; // canvas size and time accumulator (ms)
    let last = 0;             // last rAF ts

    // Palette (switches subtly in VOCALOID mode)
    function isVocaloid() {
      try { return localStorage.getItem('vocaloidMode') === 'on'; } catch { return false; }
    }
    function palette() {
      return isVocaloid()
        ? { p1: 'rgba(255,105,180,0.18)', p2: 'rgba(0,255,209,0.16)', p3: 'rgba(82,113,255,0.13)', star: 'rgba(255,255,255,', link: 'rgba(255,114,228,' }
        : { p1: 'rgba(124,58,237,0.18)', p2: 'rgba(0,199,255,0.16)', p3: 'rgba(0,255,209,0.13)', star: 'rgba(255,255,255,', link: 'rgba(0,255,209,' };
    }

    // Pointer parallax
    let pmx = 0, pmy = 0;     // pointer target in -1..1
    let mx = 0, my = 0;       // smoothed pointer
    window.addEventListener('pointermove', (e) => {
      const x = e.clientX / (innerWidth || 1);
      const y = e.clientY / (innerHeight || 1);
      pmx = x * 2 - 1; // -1..1
      pmy = y * 2 - 1; // -1..1
    }, { passive: true });

    // Stars
    const STAR_COUNT = 140;
    // Explicitly type the stars array to satisfy TS strict settings
    /** @type {any[]} */
    let stars = [];

    function resetStars() {
      stars = Array.from({ length: STAR_COUNT }, () => ({
        x: Math.random(),
        y: Math.random(),
        z: 0.25 + Math.random() * 0.75, // depth (parallax scaling)
        tw: 0.6 + Math.random() * 1.1,  // twinkle speed
        ph: Math.random() * Math.PI * 2  // twinkle phase
      }));
    }

    // Aurora blobs (metaball-like radial gradients)
    const AURORA = [
      { a: Math.random()*Math.PI*2, s: 0.00008, r: 0.55 },
      { a: Math.random()*Math.PI*2, s: 0.00006, r: 0.75 },
      { a: Math.random()*Math.PI*2, s: 0.00005, r: 0.9  }
    ];

    function resize() {
      if (!cvs || !ctx) return;
      W = cvs.width  = Math.max(1, Math.floor(window.innerWidth  * DPR));
      H = cvs.height = Math.max(1, Math.floor(window.innerHeight * DPR));
      cvs.style.width = window.innerWidth + 'px';
      cvs.style.height = window.innerHeight + 'px';
      resetStars();
    }

    function clearAndVignette() {
      if (!ctx) return;
      ctx.clearRect(0, 0, W, H);
      // subtle vignette and corner glow
      const pal = palette();
      const g = ctx.createRadialGradient(W*0.85, H*0.12, 0, W*0.85, H*0.12, Math.hypot(W, H) * 0.65);
      g.addColorStop(0.0, pal.p1);
      g.addColorStop(0.35, pal.p2);
      g.addColorStop(1.0, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);
    }

    function drawAurora() {
      if (!ctx) return;
      const pal = palette();
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const cx = W * 0.5 + mx * 30 * DPR;
      const cy = H * 0.42 + my * 20 * DPR;
      const baseR = Math.min(W, H) * 0.65;
      for (let i = 0; i < AURORA.length; i++) {
        const n = AURORA[i];
        const a = n.a + T * n.s;
        const rx = Math.cos(a * (1.0 + i*0.15)) * 0.35;
        const ry = Math.sin(a * (1.2 + i*0.1))  * 0.28;
        const x = cx + rx * baseR * 0.35;
        const y = cy + ry * baseR * 0.30;
        const R = baseR * n.r * 0.6;
        const grad = ctx.createRadialGradient(x, y, 0, x, y, R);
        if (i === 0) { grad.addColorStop(0, pal.p1); grad.addColorStop(1, 'rgba(0,0,0,0)'); }
        else if (i === 1) { grad.addColorStop(0, pal.p2); grad.addColorStop(1, 'rgba(0,0,0,0)'); }
        else { grad.addColorStop(0, pal.p3); grad.addColorStop(1, 'rgba(0,0,0,0)'); }
        ctx.beginPath();
        ctx.fillStyle = grad;
        ctx.arc(x, y, R, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawStars() {
      if (!ctx) return;
      const pal = palette();
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      for (let i = 0; i < stars.length; i++) {
        const s = stars[i];
        const px = (s.x * W) + mx * (20 * (1 - s.z)) * DPR;
        const py = (s.y * H) + my * (18 * (1 - s.z)) * DPR;
        const tw = 0.4 + 0.6 * (0.5 + 0.5 * Math.sin(T * s.tw * 0.006 + s.ph));
        const r = (0.6 + 1.8 * (1 - s.z)) * DPR;
        ctx.beginPath();
        ctx.fillStyle = pal.star + (0.25 + 0.55 * tw) + ')';
        ctx.arc(px, py, r, 0, Math.PI * 2);
        ctx.shadowColor = 'rgba(255,255,255,0.35)';
        ctx.shadowBlur = 2 * DPR;
        ctx.fill();
      }
      ctx.restore();
    }

    function drawConstellations() {
      if (!ctx) return;
      const pal = palette();
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.lineWidth = 0.8 * DPR;
      for (let i = 0; i < stars.length; i++) {
        const si = stars[i];
        const xi = (si.x * W) + mx * (20 * (1 - si.z)) * DPR;
        const yi = (si.y * H) + my * (18 * (1 - si.z)) * DPR;
        for (let j = i + 1; j < i + 10 && j < stars.length; j++) { // local neighborhood for perf
          const sj = stars[j];
          const xj = (sj.x * W) + mx * (20 * (1 - sj.z)) * DPR;
          const yj = (sj.y * H) + my * (18 * (1 - sj.z)) * DPR;
          const dx = xi - xj, dy = yi - yj;
          const d2 = dx*dx + dy*dy;
          const maxD = (110 * DPR);
          const maxD2 = maxD * maxD;
          if (d2 < maxD2) {
            const a = 1 - d2 / maxD2;
            ctx.strokeStyle = pal.link + (0.10 * a) + ')';
            ctx.beginPath(); ctx.moveTo(xi, yi); ctx.lineTo(xj, yj); ctx.stroke();
          }
        }
      }
      ctx.restore();
    }

    function drawWaves() {
      if (!ctx) return;
      ctx.save();
      ctx.globalCompositeOperation = 'soft-light';
      const baseY = H * 0.78 + my * 6 * DPR;
      const waves = [
        { amp: 10 * DPR, freq: 0.008, speed: 0.0004, color: 'rgba(255,255,255,0.06)' },
        { amp: 16 * DPR, freq: 0.006, speed: 0.0003, color: 'rgba(0,255,209,0.07)' },
        { amp: 12 * DPR, freq: 0.007, speed: 0.00035, color: 'rgba(82,113,255,0.05)' },
      ];
      for (const w of waves) {
        ctx.beginPath();
        ctx.strokeStyle = w.color;
        ctx.lineWidth = 2 * DPR;
        const step = 28 * DPR;
        for (let x = 0; x <= W + step; x += step) {
          const y = baseY + Math.sin(x * w.freq + T * w.speed) * w.amp;
          if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.stroke();
      }
      ctx.restore();
    }

    function draw() {
      clearAndVignette();
      drawAurora();
      drawStars();
      drawConstellations();
      drawWaves();
    }

    function loop() {
      const ts = performance.now();
      if (document.hidden) { last = ts; requestAnimationFrame(loop); return; }
      if (!last) last = ts;
      const dt = ts - last; last = ts; T += dt;
      // Smooth pointer toward target for fluid parallax
      mx += (pmx - mx) * 0.06; // ease
      my += (pmy - my) * 0.06;
      // Cap dt to avoid huge jumps on tab switch
      T = Math.min(T, 1e7);
      draw();
      requestAnimationFrame(loop);
    }

    window.addEventListener('resize', resize);
    resize();
    requestAnimationFrame(loop);
  }
</script>